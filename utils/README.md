# **Модуль «utils/»**
*«Модуль, реализующий методы детекции, логирования и unit-тестирования»*

Модуль включает в себя следующие компоненты:
- ```detector.py``` – реализация детекции объекта
- ```logger.py``` – система логирования
- ```tester.py``` – система unit–тестирования

Далее каждый из компонентов рассматривается детальнее.

# detector.py
*«Детекция фрагмента»*

Функция компонента использует SIFT детектор для определения ключевых точек и дескрипторов объекта и изображения. Дальнейший мэтчинг дескрипторов производится при помощи набора FLANN алгоритмов по принципу поиска k ближайших соседей (на текущий момент FLANN реализация является самой оптимальной, а k=2 – более чем достаточным). Очистка итоговых мэтчей осуществляется при помощи порогового отношения Lowe с коэффициентом 0.7, а проекция мэтчей – при помощи встроенного в OpenCV механизма гомографии. Углы и смещения объекта на изображении определятся планиметрически при помощи координат проекции, построенной на предыдущем шаге.

```python
from logger import logger

@logger ### декоратор системы логирования
def detector(
    query_path:str,
    train_path:str,
    params:dict=PARAMS, ### глобально предопределенный набор параметров
    logfile:bool=True,
    log:object=None,
    **kwargs ### экстра параметры
) -> dict:
    ...
```

Функция принимает следующие параметры:
- ```query_path:str``` – путь к эталонному изображению (объекту)
- ```train_path:str``` – путь к исследуемому изображению (изображению)
- ```params:dict``` – конфигурационный словарь с рядом тюнинг параметров:
  - ```MIN_MATCHES:int``` – минимально необходимое количество мэтчей для определения местоположения объекта на изображении и обработки исключений,
  - ```FLN_INDEX:dict``` – оптимизационные параметры индексации FLANN алгоритмов,
  - ```FLN_SEARCH:dict``` – оптимизационные параметры поиска FLANN алогритмов,
  - ```HOMOGRAPHY:dict``` - оптимизационные параметры определения гомографии;
- ```logfile:bool``` – способ логирования процесса выполнения:
  - ```= True``` - в файл директории ```logs/```
  - ```= False``` - в sys.stdout
- ```log:object``` – объект, реализующий логирование:<br>
*«По умолчанию ```log=None```, в случае использования своей системы логирования, необходима реализация на ее стороне методов ```info(...)``` и ```process(...)»```*

Функция возвращает словарь вида:
```python
{"x1":x1, "y1":y1, "x2":x2, "y2":y2, "r":r} ### где x1, y1, ... – некоторые float значения
```
... и выводит в stdout список (в дальнейшем он считывается внутри C# окружения), содержащий в себе значения смещения и поворота фрагмента относительно изображения, например:
```
[-0.1, -0.2, 3.4, 4.5, -15.0]
```
Где [0] и [1] элементы – координаты верхнего левого угла фрагмента, [2] и [3] – координаты правого нижнего угла фрагмента, и [4] элемент – его поворот с положительным значением для направления по часовой стрелке.

# logger.py
*«Система логирования»*

Система логирования реализуется как класс-декоратор поверх выполняемой задачи, и предоставляет следующие методы:
- ```init(...)``` – инициализация системы и определение параметров логирования
- ```info(...)``` – непосредственно логирование
- ```process(...)``` – обработка изображений
- ```transfer(...)``` – бэкапирование изображений в ```logs/``` директорию, перегружает ```process(...)``` функцию в случае с ```logfile=True```
- ```retain(...)``` – удаление неактуальных дневных партиций в ```logs/``` директорию

```python
class logger(object):
    ### Инициализация и метод вызова для декорации
    def __init__(self, func) -> None: self.func = func    
    def __call__(self, *args, **kwargs): return self.init(self.func, *args, **kwargs)
    ### Реализация системных методов
    def init(self, func:callable, *args, attempt:int=1, **kwargs) -> None:
        ...
    def info(self, message:str, *args, prefix:bool=True, status:str='INFO', divide:bool=False) -> None: 
        ... ### фактически реализован как self.lambda
    def process(self, path:str, type:str) -> str: 
        ...
    def transfer(self, path:str, type:str) -> str: 
        ... ### фактически реализован как self.lambda
    def retain(self, logs:str, days:int) -> None:
        ...
```

Процесс жизненного цикла системы выглядит следующим образом:
1. Определение типа логирования: запись в лог-файл или вывод в stdout;
1. Определение даты выполнения и идентификатора (форматированный datetime) задачи;
1. Если выполняется логирование в файл ~> выделение в ```logs/``` директории соответствующей поддиректории, например, ```logs/2023-03-01/```, и создание лог-файла, например, ```logs/2023-03-01/230301-044839.log```;<br>Если выполняется логирование в stdout ~> переход к следующему шагу;
1. Вызов дочернего процесса (например, детекции) с передачей ему логирующего объекта – ```self``` экземпляра;
1. В случае возникновения ошибки в дочернем процессе ~> повторный (рекурсивный) вызов ```self.init(...)``` метода со скорректированными параметрами.

Так, в результате логирования (с вызовом ```detect()``` и ```logfile=True```) в соответствующей поддиректории можно увидеть сам лог-файл, бэкапы исходных изображений и результирующее мэтч-изображение с одним и тем же идентификатором задачи в названии.

# tester.py
*«Система unit-тестирования»*

...